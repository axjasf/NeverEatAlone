```markdown:docs/features/2-service-layer/crs/CR-2025.02-50.md
# CR-2025.02-50: Architectural Consistency Fixes

## 1. Overview

This Change Request addresses critical architectural consistency issues identified during code review. The primary focus is maintaining the proper architectural flow of service → repository → ORM → domain throughout the codebase. These fixes are essential to ensure long-term maintainability, testability, and architectural integrity.

## 2. Motivation

During architectural review, several inconsistencies were identified that violate the established architectural patterns:

1. **Repository Interface Violations**: Some repository implementations don't explicitly implement their interfaces, leading to potential implementation drift.
2. **Direct ORM Access in Services**: Services sometimes bypass repositories and directly access ORM models, creating tight coupling.
3. **Inconsistent Transaction Management**: Some repositories manage their own transactions rather than letting services control transaction boundaries.

These inconsistencies lead to:
- Difficulty maintaining a clean separation of concerns
- Challenges in unit testing due to tight coupling
- Potential data integrity issues from inconsistent transaction boundaries
- Increased maintenance burden as the codebase grows

## 3. Impact Analysis

### 3.1 Affected Components

#### Repository Layer
- `SQLAlchemyContactRepository` (missing interface implementation)
- `SQLAlchemyTemplateRepository` (missing interface implementation)
- `SQLAlchemyNoteRepository` (transaction management issues)
- `SQLAlchemyTagRepository` (transaction management issues)

#### Service Layer
- `ContactService` (potential direct ORM access)
- `TemplateService` (direct ORM access in `get_current_template`)
- Other services with similar patterns

### 3.2 Risk Assessment

| Risk | Severity | Likelihood | Mitigation |
|------|----------|------------|------------|
| Breaking existing functionality | Medium | Medium | Comprehensive test coverage before/after changes |
| Transaction boundary issues | High | Low | Careful review of transaction patterns |
| Interface compatibility issues | Medium | Medium | Verify interface compliance with static analysis |
| Test failures | Medium | High | Update tests to match architectural changes |

### 3.3 Dependencies

- Base Service implementation (completed)
- Repository interfaces (existing)
- ORM models (existing)
- Domain models (existing)

## 4. Detailed Implementation Plan

### 4.1 Repository Interface Compliance

#### 4.1.1 Identify Non-Compliant Repositories

The following repositories need to be updated to explicitly implement their interfaces:

1. `SQLAlchemyContactRepository` → Implement `ContactRepository`
2. `SQLAlchemyTemplateRepository` → Implement `TemplateRepository`

#### 4.1.2 Implementation Changes

For each non-compliant repository:

```python
# Before:
class SQLAlchemyContactRepository:
    """SQLAlchemy implementation of Contact repository."""
    # ...

# After:
class SQLAlchemyContactRepository(ContactRepository):
    """SQLAlchemy implementation of Contact repository."""
    # ...
```

```python
# Before:
class SQLAlchemyTemplateRepository:
    """SQLAlchemy implementation of template repository."""
    # ...

# After:
class SQLAlchemyTemplateRepository(TemplateRepository):
    """SQLAlchemy implementation of template repository."""
    # ...
```

#### 4.1.3 Verification Steps

1. Run static type checking to verify interface compliance
2. Run existing tests to ensure functionality is preserved
3. Verify all interface methods are implemented

### 4.2 Repository Transaction Management

#### 4.2.1 Identify Transaction Management Issues

The following repositories contain direct transaction management that should be handled by services:

1. `SQLAlchemyNoteRepository.delete()` - Contains direct commit
2. `SQLAlchemyTagRepository.delete()` - Contains direct commit

#### 4.2.2 Implementation Changes

```python
# Before:
def delete(self, note: Note) -> None:
    """Delete a note."""
    stmt = (
        select(NoteORM)
        .options(
            selectinload(NoteORM.statements),
            selectinload(NoteORM.tags),
        )
        .where(NoteORM.id == note.id)
    )
    note_orm = self._session.execute(stmt).unique().scalar_one_or_none()
    if note_orm:
        self._session.delete(note_orm)
        self._session.commit()  # Remove this line

# After:
def delete(self, note: Note) -> None:
    """Delete a note."""
    stmt = (
        select(NoteORM)
        .options(
            selectinload(NoteORM.statements),
            selectinload(NoteORM.tags),
        )
        .where(NoteORM.id == note.id)
    )
    note_orm = self._session.execute(stmt).unique().scalar_one_or_none()
    if note_orm:
        self._session.delete(note_orm)
        # Transaction management handled by service
```

```python
# Before:
def delete(self, tag: Tag) -> None:
    """Delete a tag."""
    tag_orm = self.session.get(TagORM, tag.id)
    if tag_orm:
        self.session.delete(tag_orm)
        self.session.commit()  # Remove this line

# After:
def delete(self, tag: Tag) -> None:
    """Delete a tag."""
    tag_orm = self.session.get(TagORM, tag.id)
    if tag_orm:
        self.session.delete(tag_orm)
        # Transaction management handled by service
```

#### 4.2.3 Verification Steps

1. Update service tests to verify transaction boundaries
2. Ensure all repository operations are properly committed by services
3. Verify rollback behavior in error scenarios

### 4.3 Service Layer Abstraction

#### 4.3.1 Identify Direct ORM Access

The following service methods contain direct ORM access that should be moved to repositories:

1. `TemplateService.get_current_template()` - Direct ORM query
2. Any similar patterns in other services

#### 4.3.2 Implementation Changes

First, add appropriate methods to repository interfaces:

```python
class TemplateRepository(Protocol):
    """Interface for template persistence."""

    # Existing methods...

    def get_latest_template(self) -> Optional[Template]:
        """Get the latest version of any template.

        Returns:
            The latest template version or None if no templates exist
        """
        ...
```

Then implement in the repository:

```python
def get_latest_template(self) -> Optional[Template]:
    """Get the latest version of any template."""
    stmt = (
        select(TemplateVersionORM)
        .order_by(desc(TemplateVersionORM.version))
        .limit(1)
    )
    template_orm = self._session.execute(stmt).scalar_one_or_none()

    if template_orm is None:
        return None

    return self._to_domain(template_orm)
```

Finally, update the service to use the repository method:

```python
# Before:
def get_current_template(self) -> Template:
    """Get the current template."""
    with self.in_transaction() as session:
        try:
            stmt = select(TemplateVersionORM).order_by(desc(TemplateVersionORM.version))
            template = session.execute(stmt).scalars().first()
            # ...

# After:
def get_current_template(self) -> Template:
    """Get the current template."""
    with self.in_transaction() as session:
        try:
            template_repo = SQLAlchemyTemplateRepository(session)
            template = template_repo.get_latest_template()
            if not template:
                raise NotFoundError("No template found")
            return template
        except Exception as e:
            raise self.handle_error("get_current_template", e)
```

#### 4.3.3 Verification Steps

1. Ensure all ORM access is moved to repositories
2. Update service tests to use mocked repositories
3. Verify functionality with integration tests

## 5. Testing Strategy

### 5.1 Unit Tests

#### 5.1.1 Repository Tests

For each modified repository:
1. Test interface compliance
2. Verify transaction management is removed
3. Test new repository methods

Example test for `get_latest_template`:

```python
def test_get_latest_template(db_session):
    """Test retrieving the latest template version."""
    # Arrange
    repo = SQLAlchemyTemplateRepository(db_session)
    template1 = Template(version=1, categories={})
    template2 = Template(version=2, categories={})
    repo.save(template1)
    repo.save(template2)

    # Act
    latest = repo.get_latest_template()

    # Assert
    assert latest is not None
    assert latest.version == 2
```

#### 5.1.2 Service Tests

For each modified service:
1. Test using repository methods instead of direct ORM access
2. Verify transaction boundaries
3. Test error handling

Example test for updated `get_current_template`:

```python
def test_get_current_template(template_service, mock_template_repository):
    """Test retrieving current template using repository."""
    # Arrange
    mock_template = Template(version=1, categories={})
    mock_template_repository.get_latest_template.return_value = mock_template

    # Act
    result = template_service.get_current_template()

    # Assert
    assert result == mock_template
    mock_template_repository.get_latest_template.assert_called_once()
```

### 5.2 Integration Tests

1. Verify end-to-end functionality with real database
2. Test transaction boundaries across multiple operations
3. Verify error scenarios and rollback behavior

## 6. Implementation Phases

### 6.1 Phase 1: Repository Interface Compliance (Priority 1)

1. Update `SQLAlchemyContactRepository` to implement `ContactRepository`
2. Update `SQLAlchemyTemplateRepository` to implement `TemplateRepository`
3. Verify interface compliance with static analysis
4. Run existing tests to ensure functionality is preserved

### 6.2 Phase 2: Repository Transaction Management (Priority 1)

1. Remove direct commit/rollback calls from `SQLAlchemyNoteRepository.delete()`
2. Remove direct commit/rollback calls from `SQLAlchemyTagRepository.delete()`
3. Update service implementations to ensure proper transaction management
4. Add tests to verify transaction boundaries

### 6.3 Phase 3: Service Layer Abstraction (Priority 2)

1. Identify all instances of direct ORM access in services
2. Add appropriate methods to repository interfaces
3. Implement new repository methods
4. Update services to use repository methods
5. Update tests to verify proper abstraction

## 7. Documentation Updates

### 7.1 Architecture Documentation

Update `docs/features/2-service-layer/design/SERVICE_ARCHITECTURE.md`:
- Clarify layer responsibilities
- Document transaction management patterns
- Emphasize repository abstraction principles

### 7.2 Repository Interface Documentation

Update repository interface documentation to clarify:
- Transaction management responsibilities
- Interface compliance requirements
- New methods added for service abstraction

### 7.3 Test Pattern Documentation

Update `docs/features/1-data-model/design/TEST_PATTERNS.md`:
- Add patterns for testing repository abstraction
- Document transaction boundary testing
- Update service test patterns

## 8. Backward Compatibility

These changes maintain backward compatibility at the API level while improving internal architecture. No database schema changes are required.

## 9. Rollback Plan

If issues arise:
1. Revert to previous implementation
2. Document specific architectural violations that couldn't be fixed
3. Create targeted CRs for individual issues

## 10. Conclusion

These architectural consistency fixes will ensure proper separation of concerns, improve testability, and maintain the integrity of the service → repository → ORM → domain flow. By addressing these issues now, we prevent architectural drift and reduce technical debt as the codebase grows.
```
